var documenterSearchIndex = {"docs":
[{"location":"utility/#Utility","page":"Utility","title":"Utility","text":"","category":"section"},{"location":"utility/","page":"Utility","title":"Utility","text":"Here we describe some external tools that can assist the development of Vulkan applications.","category":"page"},{"location":"utility/#Profilers","page":"Utility","title":"Profilers","text":"","category":"section"},{"location":"utility/#NVIDIA-Nsight-Systems","page":"Utility","title":"NVIDIA Nsight Systems","text":"","category":"section"},{"location":"utility/","page":"Utility","title":"Utility","text":"NVIDIA Nsight Systems is a tool developed by NVIDIA to profile applications, showing both CPU and GPU usage. It can be very useful for analyzing the balance between CPU and GPU usage, as well as troubleshoot general performance bottlenecks. However, it only outputs high-level information regarding GPU tasks. Therefore, to catch GPU bottlenecks on a low-level (such as inside shaders) one should instead use a dedicated profiler such as Nsight Graphics or Renderdoc.","category":"page"},{"location":"utility/#nsight-graphics","page":"Utility","title":"NVIDIA Nsight Graphics","text":"","category":"section"},{"location":"utility/","page":"Utility","title":"Utility","text":"Nsight Graphics dives deeper into the execution details of an application and provides detailed information regarding graphics pipelines, shaders and so on. This is a tool of choice to consider for NVIDIA GPUs once the GPU is identified as a bottleneck with Nsight Systems.","category":"page"},{"location":"utility/#renderdoc","page":"Utility","title":"Renderdoc","text":"","category":"section"},{"location":"utility/","page":"Utility","title":"Utility","text":"Renderdoc plays a similar role to Nsight Graphics for a wider range of GPUs. It is open-source and community-maintained.","category":"page"},{"location":"utility/#CPU-implementation","page":"Utility","title":"CPU implementation","text":"","category":"section"},{"location":"utility/","page":"Utility","title":"Utility","text":"SwiftShader is a CPU implementation of Vulkan primarily designed to extend the portability of Vulkan applications. It can be used wherever there is a lack of proper driver support, including public continuous integration services.","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"DocTestSetup = quote\n    instance = Instance(String[], String[])\n    physical_device = first(enumerate_physical_devices(instance))\nend","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Vulkan]\nPrivate = false","category":"page"},{"location":"api/#Vulkan.DebugUtilsMessengerEXT-Tuple{Instance,Ptr{Nothing}}","page":"API","title":"Vulkan.DebugUtilsMessengerEXT","text":"Register a user callback and return the corresponding messenger.\n\nA default named default_debug_callback can be converted to a function pointer to use as a callback.\n\nwarning: Warning\ncallback must be a function pointer of type Ptr{Nothing} obtained from a callback_f function as follows:   callback = @cfunction(callback_f, UInt32, (VkDebugUtilsMessageSeverityFlagBitsEXT, VkDebugUtilsMessageTypeFlagBitsEXT, Ptr{vk.VkDebugUtilsMessengerCallbackDataEXT}, Ptr{Cvoid}))   with callback_f a Julia function with a signature matching the @cfunction call.\n\nDebugUtilsMessengerEXT(instance::Instance, callback::Ptr{Nothing}; severity, types) -> DebugUtilsMessengerEXT\n\n\n\n\n\n\n","category":"method"},{"location":"api/#Vulkan.Handle","page":"API","title":"Vulkan.Handle","text":"Opaque handle referring to internal Vulkan data. Finalizer registration is taken care of by constructors.\n\nabstract type Handle <: VulkanStruct{false}\n\n\n\n\n\n","category":"type"},{"location":"api/#Vulkan.PhysicalDeviceFeatures-Tuple{AbstractArray}","page":"API","title":"Vulkan.PhysicalDeviceFeatures","text":"Return a PhysicalDeviceFeatures object with the fields present in features set to true.\n\njulia> PhysicalDeviceFeatures([])\nPhysicalDeviceFeatures()\n\njulia> PhysicalDeviceFeatures([:wideLines, :sparseBinding])\nPhysicalDeviceFeatures(wideLines, sparseBinding)\n\nPhysicalDeviceFeatures(features::AbstractArray) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"api/#Vulkan.ReturnedOnly","page":"API","title":"Vulkan.ReturnedOnly","text":"Represents a structure that will never be requested by API functions.\n\nabstract type ReturnedOnly <: VulkanStruct{false}\n\n\n\n\n\n","category":"type"},{"location":"api/#Vulkan.VulkanError","page":"API","title":"Vulkan.VulkanError","text":"Exception type indicating that an API function returned a non-success code.\n\nstruct VulkanError <: Exception\n\nmsg::AbstractString\nreturn_code::Any\n\n\n\n\n\n","category":"type"},{"location":"api/#Vulkan.VulkanStruct","page":"API","title":"Vulkan.VulkanStruct","text":"Represents any kind of wrapper structure that was generated from a Vulkan structure. D is a Bool parameter indicating whether the structure has specific dependencies or not.\n\n\n\n\n\n","category":"type"},{"location":"api/#Vulkan.find_queue_index-Tuple{PhysicalDevice,Any}","page":"API","title":"Vulkan.find_queue_index","text":"Find a queue index (starting at 0) from physical_device which matches the provided queue_capabilities. queue_capabilities can be combination of VkQueueFlagBits.\n\njulia> find_queue_index(physical_device, VK_QUEUE_COMPUTE_BIT & VK_QUEUE_GRAPHICS_BIT)\n0\n\nfind_queue_index(physical_device::PhysicalDevice, queue_capabilities::Any) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"api/#Vulkan.@check-Tuple{Any}","page":"API","title":"Vulkan.@check","text":"@check vkCreateInstance(args...)\n\nIf the expression does not return VK_SUCCESS, raise a VulkanError holding the return code.\n\nRequires the ERROR_CHECKING preference enabled.\n\n\n\n\n\n","category":"macro"},{"location":"intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"intro/#What-is-Vulkan?","page":"Introduction","title":"What is Vulkan?","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Vulkan is a graphics and compute specification, targeting a broad range of GPUs and even CPUs. It aims to provide a cross-platform API that can be used from PCs, consoles, mobile phones and embedded platforms. It can be thought of as the new generation of OpenGL with the compute capabilities of OpenCL. It should be noted that Vulkan is merely a specification and therefore, there does not exist only one Vulkan library but rather multiple device-dependent implementations conforming to a unique standard. The version of the Vulkan implementation you may be using thus depends on the graphics drivers installed on your system.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The power of this standard lies in the genericity it guarantees to anything that builds from it. This is a direct consequence of a thorough testing of vendor implementations, which must be compatible with the specification in every detail. Therefore, tools that are developped for Vulkan can be used throughout the entire ecosystem, available for all devices that support Vulkan.","category":"page"},{"location":"intro/#Compute-and-graphics-interface","page":"Introduction","title":"Compute and graphics interface","text":"","category":"section"},{"location":"intro/#SPIR-V","page":"Introduction","title":"SPIR-V","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"To describe how graphics and compute programs should be executed by devices, Vulkan relies on the Standard Portable Intermediate Representation (SPIR-V) format. This is another specification, whose aim is to free hardware vendors from having to build their own compiler for every shading/compute language, whose implementations were not always coherent with one another. It is a binary format, making it easier to generate assembly code from than text-based formats (such as GLSL and HLSL).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"SPIR-V is not a language, but rather a binary format that higher level languages can compile to. It can be targeted from shading languages; for example, see Khronos' glslang and Google's shaderc for GLSL/HLSL. SPIR-V features a large suite of tools, designed to ease the manipulation of SPIR-V programs. It includes an optimizer, spirv-opt, alleviating the need for hardware vendors to have their own SPIR-V optimizer.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"SPIR-V is notably suited to cross-compilation among shading languages (see SPIR-V Cross).","category":"page"},{"location":"intro/#SPIR-V-and-LLVM","page":"Introduction","title":"SPIR-V and LLVM","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"SPIR-V is similar to LLVM IR, for which there exists a bi-directional translator. However, not all SPIR-V concepts are mappable to LLVM IR, so not all of SPIR-V can be translated. Currently, only the OpenCL part of SPIR-V is supported by this translator (see this issue), missing essential features required by Vulkan. If (or when) Vulkan is supported, Julia code could be compiled to LLVM, translated to SPIR-V and executed from any supported Vulkan device, be it for graphics or compute jobs. For the moment, SPIR-V modules to be consumed by Vulkan are usually compiled from other shading languages.","category":"page"},{"location":"design/#Design","page":"Design","title":"Design","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Vulkan is a low-level API that exhibits many patterns than any C library exposes. For example, some functions return error codes as a result, or mutate pointer memory as a way of returning values. The length of array pointers is always requested, while trivially available when originating from Julia arrays. Pointers are the primary objects of interest, while it is not trivial to keep them valid (i.e. have them point to valid memory) in Julia. Their validity is not guaranteed out of the box, which introduces several pitfalls that ultimately lead to crashes. Notably, the API makes a heavy use of structures with pointer fields and structure pointers, which demands a clear knowledge of variable preservation in Julia.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Usually, the patterns mentioned above are not problematic for small libraries, because structures are relatively simple. They however become visible annoyances in the case of a large API such as Vulkan. This motivates the use of a procedural approach to handle those patterns.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Vulkan.jl uses a generator to programmatically generate higher-level wrappers for low-level API functions. This is a consequent part of this library, which helped us to minimize the amount of human errors in the wrapping process, while allowing a certain flexilibity. The related project is found in the generator folder. Because its unique purpose is to generate the wrapper generated/vulkan_wrapper.jl, it is not included in the package, which results in a lightweight library.","category":"page"},{"location":"features/#Features","page":"Features","title":"Features","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"This wrapper exposes several features aimed at simplifying the use of the Vulkan API from Julia. Some features are configurable through the recent Preferences.jl package, see the corresponding section for a list of available options.","category":"page"},{"location":"features/#Automatic-error-checking","page":"Features","title":"Automatic error checking","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"Codes returned by functions are automatically checked for, and a VulkanError is thrown whenever a non-success code is encountered. To handle non-success return codes it may be desirable to wrap the function call in a try/catch block and check the return_code field of the thrown exception. For example:","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"try\n    Instance(InstanceCreateInfo(String[], String[]))\ncatch e\n    if e isa VulkanError && e.return_code == VK_INCOMPATIBLE_DRIVER\n        error(\"No driver compatible with the requested API version could be found.\n               Please make sure that a driver supporting Vulkan is installed, and\n               that it is up to date with the requested version.\")\n    else\n        rethrow()\n    end\nend","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"For non-error (but non-success) codes, you will also have to wrap code in the same fashion:","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"while true\n    try\n        return acquire_next_image_khr(device, swapchain, 1)\n    catch e\n        if e isa VulkanError && e.return_code == VK_TIMEOUT\n            @debug \"Swapchain image acquisition timed out.\"\n        else\n            rethrow()\n        end\n    end\nend","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"Although this is not recommended, you can disable this feature by setting the preference ERROR_CHECKING to false (see Preferences). Note, however, that if ERROR_CHECKING is disabled the return code is not accessible from the wrapper at the moment.","category":"page"},{"location":"features/#Handles","page":"Features","title":"Handles","text":"","category":"section"},{"location":"features/#Automatic-finalization","page":"Features","title":"Automatic finalization","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"Handles can be created with the API functions vkCreate* and vkAllocate*, and most of them must be destroyed after use with a vkDestroy* or vkFree*. More importantly, they must be destroyed with the same allocator and parent handle that created them. To facilitate this, new mutable handle types were defined to allow for the registration of a finalizer. Instead of having to manually specify the finalizer for each handle instance, the create_* and allocate_* wrappers automatically register the corresponding destructor.","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"However, finalizers can be run in arbitrary order, and some handles require to be destroyed only after all their children (such as VkDevices). To avoid crashes related to bad finalization execution order, a simple thread-safe reference counting system is used to make sure that a handle is destroyed only after all its children are destroyed.","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"This introduces a small overhead, since the parent handle and allocator are stored in an anonymous function for each handle at creation. However, it should be minor compared to the execution time of the API destructors.","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"There are exceptions to the described above. CommandBuffers and DescriptorSets do not register any destructor and are never implicitly freed. You will have to explicitly free those resources yourself with free_command_buffers and free_descriptor_sets respectively. The reason for that is that they are supposed to be freed in batches for performance considerations. Please note also that, except for these two handle types, you should never explicitly call the destructors, otherwise they will be destroyed twice, likely resulting in a crash.","category":"page"},{"location":"features/#Expose-*[Create/Allocate]Info-arguments","page":"Features","title":"Expose *[Create/Allocate]Info arguments","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"Handles that can only be created with a single API constructor possess an additional constructor that wraps around the generated create/allocate* functions, building the required *[Create/Allocate]Info from exposed arguments. That way, you do not have to explicitly construct this intermediate structure, which reduces boilerplate code.","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"For example","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"fence = Fence(device, FenceCreateInfo())\nfence_signaled = Fence(device, FenceCreateInfo(flags=VK_FENCE_CREATE_SIGNALED_BIT);\n                       allocator=my_allocator)","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"can be replaced with","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"fence = Fence(device)\nfence_signaled = Fence(device, flags=VK_FENCE_CREATE_SIGNALED_BIT; allocator=my_allocator)","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"When multiple info structures are requested, only the main one is exposed","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"# the ApplicationInfo has to be provided manually\ninstance = Instance(String[], String[]; application_info = ApplicationInfo(...))\n...\n# the array of DeviceQueueCreateInfo has to be provided manually\ndevice = Device(physical_device, [DeviceQueueCreateInfo(0, [1.0])], String[], String[])","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"When multiple handles are constructed at the same time, no additional constructor is defined and you need to call the create_* function manually","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"pipelines = create_graphics_pipelines(device, [GraphicsPipelineCreateInfo(...)])\ncommand_buffers = allocate_command_buffers(device, CommandBufferAllocateInfo(\n                                           command_pool, VK_COMMAND_BUFFER_LEVEL_PRIMARY, 3))","category":"page"},{"location":"features/#Functions","page":"Features","title":"Functions","text":"","category":"section"},{"location":"features/#Implicit-return-values","page":"Features","title":"Implicit return values","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"Functions almost never directly return a value in Vulkan, and usually return either a return code or nothing. This is a limitation of C where only one value can be returned. Instead, they fill pointers with data, and it is your responsibility to initialize them before the call and dereference them afterwards. In Julia, it can be repetitive, requiring a special handling such as","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"pDisplay = Ref{VkDisplayKHR}()\n@check vkGetRandROutputDisplayEXT(physical_device, dpy_ref, rr_output, pDisplay)\npDisplay[]\n\n# or, showing what is actually done by the wrapper instead\nDisplayKHR(pDisplay[], identity, physical_device)","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"This particular setup is taken care of by the wrapper, so that you only need to do:","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"display = get_rand_r_output_display_ext(physical_device, dpy_ref, rr_output)","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"When there are multiple implicit return values (i.e. multiple pointers being written to), they are returned as a tuple:","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"actual_data_size, data = get_pipeline_cache_data(device, pipeline_cache, data_size)","category":"page"},{"location":"features/#Enumerated-arrays","page":"Features","title":"Enumerated arrays","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"Sometimes, when enumerating objects or properties for example, a function may need to be called twice: a first time for returning the number of elements to be enumerated, then a second time with an initialized array of the right length to be filled with Vulkan objects:","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"pPhysicalDeviceCount = Ref{UInt32}(0)\n\n# get the length in pPhysicalDeviceCount\n@check vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, C_NULL)\n\n# initialize the array with the returned length\npPhysicalDevices = Vector{VkPhysicalDevice}(undef, pPhysicalDeviceCount[])\n\n@check vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices)\n\n# optional\nPhysicalDevices.(pPhysicalDevices, identity, instance)","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"The relevant enumeration functions are wrapped with this, so that only one call needs to be made, without worrying about creating intermediate arrays:","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"physical_devices = enumerate_physical_devices(instance)","category":"page"},{"location":"features/#Types","page":"Features","title":"Types","text":"","category":"section"},{"location":"features/#Structures","page":"Features","title":"Structures","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"As the API is written in C, there are a lot of pointers to deal with and handling them is not always an easy task. With a little practice, one can figure out how to wrap function calls with cconvert and unsafe_convert provided by Julia. Those functions provide automatic conversions and ccall GC-roots cconverted variables to ensure that pointers will point to valid memory (by explicitly telling the compiler not to garbage-collect nor optimize away the original variable).","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"However, the situation gets a lot more complicated when you deal with pointers as type fields. We will look at a naive example that show how difficult it can get for a Julia developer not used to calling C code. If we wanted to create a VkInstance, we might be tempted to do:","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"function create_instance(app_name, engine_name)\n    app_info = VkApplicationInfo(\n        VK_STRUCTURE_TYPE_APPLICATION_INFO, # sType\n        C_NULL, # pNext\n        pointer(app_name), # application name\n        1, # application version\n        pointer(engine_name), # engine name\n        0, # engine version\n        VK_VERSION_1_2, # requested API version\n    )\n    create_info = InstanceCreateInfo(\n        VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO, # sType\n        C_NULL, # pNext\n        0, # flags\n        Base.unsafe_convert(Ptr{VkApplicationInfo}, (Ref(app_info))), # application info\n        0, # layer count\n        C_NULL, # layers (none requested)\n        0, # extension count\n        C_NULL, # extensions (none requested)\n    )\n    p_instance = Ref{VkInstance}()\n\n    GC.@preserve app_info begin\n        vkCreateInstance(\n            Ref(create_info),\n            C_NULL, # custom allocator (we choose the default one provided by Vulkan)\n            p_instance,\n        )\n    end\n\n    p_instance[]\nend\n\ninstance = create_instance(\"AppName\", \"NoEngine\") # very likely to segfault","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"which will probably result in a segmentation fault. Why?","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"Two causes may lead to such a result:","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"app_name and engine_name may never be allocated if the compiler decides not to, so there is no guarantee that pointer(app_name) and pointer(engine_name) will point to anything valid. Additionally, even if those variables were allocated with valid pointer addresses at some point, they can be garbage collected at any time, including before the call to vkCreateInstance.\napp_info is not what should be preserved. It cannot be converted to a pointer, but a Ref to it can. Therefore it is the reference that needs to be GC.@preserved, not app_info. So, Ref(app_info) must be assigned to a variable, and replace app_info in the call to GC.@preserve.","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"Basically, it all comes down to having to preserve everything you take a pointer of. And, if you need to create an intermediary object when converting a variable to a pointer, you need to preserve it too. For example, take of an array of Strings, that need to be converted as a Ptr{Cstring}. You first need to create an array of Cstrings, then convert that array to a pointer. The Strings and the Cstring array need to be preseved.","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"This is exactly what cconvert and unsafe_convert are for. cconvert converts a variable to a type that can be converted to the desired (possibly pointer) type using unsafe_convert. In addition of chaining both conversions, ccall also preserves the cconverted variable, so that the unsafe conversion becomes safe.","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"Because we cannot use ccall in this case, we need to cconvert any argument that will be transformed to a pointer, and store the result as long as the desired struct may be used. Then, unsafe_convert can be called on this result, to get the desired (pointer) type necessary to construct the API struct.","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"There are several possibilities for preserving what we may call \"pointer dependencies\". One of them is to reference them inside a global variable, such as a Dict, and deleting them once we no longer need it. This has the severe disadvantage of requiring to explicitly manage every dependency, along with large performance issues. Another possibility, which we have taken in this wrapper, is to create a new structure that will store both the API structure and the required dependencies. That way, we can safely rely on the GC for preserving what we need just when we need it.","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"Therefore, every API structure is wrapped inside another one (without the \"Vk\" prefix), as follows:","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"struct InstanceCreateInfo <: VulkanStruct{true} # true means there are dependencies\n    vks::VkInstanceCreateInfo # API struct\n    deps::Vector{Any}         # contains all required dependencies\nend","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"and every structure exposes a convenient constructor that works perfectly with Strings and mutable AbstractArrays. No manual Refs/cconvert/unsafe_convert needed.","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"We hope that the additional Vector{Any} will not introduce too much overhead. In the future, this might be changed to a NTuple{N, Any} or a StaticArrays.SVector{N, Any}. We could also have stored dependencies as additional fields, but this does not scale well with nested structs. It would either require putting an additional field for each dependency (be it direct, or indirect dependencies coming from a pointer to another struct), possibly defining other structures that hold dependencies to avoid having a large number of fields, inducing additional compilation time.","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"note: Note\ncconvert/unsafe_convert were extended so that, when using an API function directly, ccall will convert a struct to its vks field. Therefore, there is no need to specify it manually in that case.","category":"page"},{"location":"features/#Conversion","page":"Features","title":"Conversion","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"In Vulkan, version numbers are UInt32 with a special encoding to extract major, minor and patch numbers, booleans are represented as UInt32 values, Strings as Ptr{UInt8} or NTuple{N, UInt8}. Those types have a natural counterpart in Julia, being respectively VersionNumber, Bool and String types. The wrapper makes it possible to work with these Julian types, automatically converting them wherever necessary.","category":"page"},{"location":"features/#Automatic-insertion-of-inferable-arguments","page":"Features","title":"Automatic insertion of inferable arguments","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"In some places, part of the arguments of a function or of the fields of a structure can only take one logical value. It can be divided into two sets:","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"The structure type sType of certain structures\nArguments related to the start and length of a pointer which represents an array","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"The second set is a consequence of using a higher-level language than C. In C, the pointer alone does not provide any information regarding the number of elements it holds. In Julia, array-like values can be constructed in many different ways, being an Array, a NTuple or other container types which provide a length method.","category":"page"},{"location":"features/#Structure-type","page":"Features","title":"Structure type","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"Many API structures possess a sType field which must be set to a unique value. This is done to favor the extendability of the API, but is unnecessary boilerplate for the user. Worse, this is an error-prone process which may lead to crashes. All the constructors of this wrapper do not expose this sType argument, and hardcode the expected value.","category":"page"},{"location":"features/#Pointer-lengths","page":"Features","title":"Pointer lengths","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"The length of array pointers is automatically deduced from the length of the container passed in as argument.","category":"page"},{"location":"features/#Pointer-starts","page":"Features","title":"Pointer starts","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"Some API functions require to specify the start of a pointer array as an argument. They have been hardcoded to 0 (first element), since it is always possible (and very straightforward) to pass in a sub-array.","category":"page"},{"location":"features/#preferences","page":"Features","title":"Preferences","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"Some of the above features have configurable options that can be set via Preferences.jl.","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"warning: Warning\nPreferences require running at least Julia 1.6. For earlier versions, these options are not customizable, and will have their default values.","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"Preference Description Default\nERROR_CHECKING Whether API return codes should be automatically checked for errors true","category":"page"},{"location":"troubleshooting/#Troubleshooting","page":"Troubleshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Here we list common errors that can be encountered, with common solutions.","category":"page"},{"location":"troubleshooting/#VK_ERROR_LAYER_NOT_PRESENT","page":"Troubleshooting","title":"VK_ERROR_LAYER_NOT_PRESENT","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Most layers are not bundled with the default Vulkan driver. For example, the validation layer VK_LAYER_KHRONOS_validation should be installed from their Github Page. This specific layer should hopefully be integrated in the artifact system in the future, but other layers may be vendor-dependent, and therefore it is the responsibility of the user to install them before hand.","category":"page"},{"location":"troubleshooting/#Validation-layers-'GLIBCXX_X.X.XX'-not-found","page":"Troubleshooting","title":"Validation layers - 'GLIBCXX_X.X.XX' not found","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"The Khronos validation layer requires a libstc++ more recent than the old found on some Julia binaries. A workaround is to build Julia from source, with an up to date libstdc++ on the system, as indicated in this issue on Discourse.","category":"page"},{"location":"troubleshooting/#based-vs-1-based-indexing","page":"Troubleshooting","title":"0-based vs 1-based indexing","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Vulkan uses a 0-based indexing system, so be careful whenever an index is returned from or requested for a Vulkan function.","category":"page"},{"location":"#Vulkan.jl","page":"Home","title":"Vulkan.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Vulkan.jl is a lightweight wrapper around the Vulkan graphics and compute library. It exposes abstractions over the underlying C interface, primarily geared towards developers looking for a more natural way to work with Vulkan with minimal overhead.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It builds upon the core API provided by VulkanCore.jl. Because Vulkan is originally a C specification, interfacing with it requires some knowledge before correctly being used from Julia. This package acts as an abstraction layer, so that you don't need to know how to properly call a C library, while still retaining full functionality. The wrapper is generated directly from the Vulkan Specification.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is a very similar approach to that taken by VulkanHpp, except that the target language is Julia and not C++.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"intro.md\", \"features.md\", \"api.md\", \"utility.md\", \"troubleshooting.md\"]","category":"page"}]
}
