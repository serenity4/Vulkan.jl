var documenterSearchIndex = {"docs":
[{"location":"utility/#Utility-tools","page":"Utility","title":"Utility tools","text":"","category":"section"},{"location":"utility/#Profilers","page":"Utility","title":"Profilers","text":"","category":"section"},{"location":"utility/#NVIDIA-Nsight-Systems","page":"Utility","title":"NVIDIA Nsight Systems","text":"","category":"section"},{"location":"utility/","page":"Utility","title":"Utility","text":"NVIDIA Nsight Systems is a tool developed by NVIDIA to profile applications, showing both CPU and GPU usage. It can be very useful for analyzing the balance between CPU and GPU usage, as well as troubleshoot general performance bottlenecks. However, it only outputs high-level information on the GPU tasks. Therefore, to catch GPU bottlenecks on a low-level one should instead use a dedicated profiler such as Nsight Graphics or Renderdoc.","category":"page"},{"location":"utility/#ngfx","page":"Utility","title":"NVIDIA Nsight Graphics","text":"","category":"section"},{"location":"utility/","page":"Utility","title":"Utility","text":"Nsight Graphics dives deeper into the execution details of an application and provides detailed information regarding graphics pipelines, shaders and so on. This is a tool of choice to consider for NVIDIA GPUs once the GPU is identified as a bottleneck with Nsight Systems.","category":"page"},{"location":"utility/#renderdoc","page":"Utility","title":"Renderdoc","text":"","category":"section"},{"location":"utility/","page":"Utility","title":"Utility","text":"Renderdoc plays a similar role to Nsight Graphics for a wider range of GPUs. It is open-source and community-maintained.","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Vulkan]\nPrivate = false","category":"page"},{"location":"api/#Vulkan.DebugUtilsMessengerEXT-Tuple{Instance,Ptr{Nothing}}","page":"API","title":"Vulkan.DebugUtilsMessengerEXT","text":"Register a user callback and return the corresponding messenger.\n\nA default named default_debug_callback can be converted to a function pointer to use as a callback.\n\nwarning: Warning\ncallback must be a function pointer of type Ptr{Nothing} obtained from a callback_f function as follows:   callback = @cfunction(callback_f, UInt32, (VkDebugUtilsMessageSeverityFlagBitsEXT, VkDebugUtilsMessageTypeFlagBitsEXT, Ptr{vk.VkDebugUtilsMessengerCallbackDataEXT}, Ptr{Cvoid}))   with callback_f a Julia function with a signature matching the @cfunction call.\n\nDebugUtilsMessengerEXT(instance::Instance, callback::Ptr{Nothing}; severity, types) -> DebugUtilsMessengerEXT\n\n\n\n\n\n\n","category":"method"},{"location":"api/#Vulkan.Handle","page":"API","title":"Vulkan.Handle","text":"Opaque handle referring to internal Vulkan data. Finalizer registration is taken care of by constructors.\n\nabstract type Handle <: VulkanStruct{false}\n\n\n\n\n\n","category":"type"},{"location":"api/#Vulkan.ReturnedOnly","page":"API","title":"Vulkan.ReturnedOnly","text":"Represents a structure that will never be requested by API functions.\n\nabstract type ReturnedOnly <: VulkanStruct{false}\n\n\n\n\n\n","category":"type"},{"location":"api/#Vulkan.VulkanError","page":"API","title":"Vulkan.VulkanError","text":"Exception type indicating that an API function returned a non-success code.\n\nstruct VulkanError <: Exception\n\nmsg::AbstractString\nreturn_code::Any\n\n\n\n\n\n","category":"type"},{"location":"api/#Vulkan.VulkanStruct","page":"API","title":"Vulkan.VulkanStruct","text":"Represents any kind of wrapper structure that was generated from a Vulkan structure. D is a Bool parameter indicating whether the structure has specific dependencies or not.\n\n\n\n\n\n","category":"type"},{"location":"api/#Vulkan.@check-Tuple{Any}","page":"API","title":"Vulkan.@check","text":"@check vkCreateInstance(args...)\n\nIf the expression does not return VK_SUCCESS, raise a VulkanError holding the return code.\n\nRequires the ERROR_CHECKING preference enabled.\n\n\n\n\n\n","category":"macro"},{"location":"generator/","page":"Generator","title":"Generator","text":"Vulkan is a low-level API that exhibits many patterns than any C library exposes. For example, some functions return error codes as a result, or mutate pointer memory as a way of returning multiple values (what would correspond to Julia Arrays). The length of array pointers are requested, while directly available as a Julia object. Pointers are the primary objects of interest, while it is not trivial to keep them valid (i.e. have them point to valid memory) in Julia. Their validity is not guaranteed out of the box, which introduces several pitfalls that ultimately lead to crashes. Notably, the API makes a heavy use of structures with pointer fields and structure pointers, which demands a clear knowledge of variable preservation in Julia.","category":"page"},{"location":"generator/","page":"Generator","title":"Generator","text":"Usually, the patterns mentioned above are not problematic for small libraries, because structures are relatively simple. They however become visible annoyances in the case of a large API such as Vulkan. This motivates the use of a procedural approach to handle those patterns.","category":"page"},{"location":"generator/","page":"Generator","title":"Generator","text":"Vulkan.jl uses a generator to programmatically generate higher-level wrappers for low-level API functions. This is a consequent part of this library, which allowed us to minimize the amount of human errors in the wrapping process, dealing with the patterns mentioned above. The related project is found in the generator folder. Its unique purpose is to generate the file generated/wrapped_api.jl.","category":"page"},{"location":"generator/#Wrapper-content","page":"Generator","title":"Wrapper content","text":"","category":"section"},{"location":"generator/#Structures","page":"Generator","title":"Structures","text":"","category":"section"},{"location":"generator/","page":"Generator","title":"Generator","text":"API structures often use pointer fields to pass other structures around, or to have the pointed object filled in by the API, similarly to an assignment. To function properly in Julia, the pointed data has to be conserved in order for the pointer to be valid. Having it conserved here means that it should not be garbage-collected, and used so that compiler optimizations cannot decide to elide the computation. A common way to do this is to store the data in structure fields. Therefore, API structures should have additional fields to preserve variables that are in use by a pointer. However, changing their layout would make them unsuitable for API calls. New structures were generated for each corresponding API structure. They have two fields:","category":"page"},{"location":"generator/","page":"Generator","title":"Generator","text":"a vks field, which holds the API structure,\na bag field, which contains all dependencies required for the API structure to work properly. This mostly includes original data that is used by pointers.","category":"page"},{"location":"generator/","page":"Generator","title":"Generator","text":"When using an API function with ccall, the vks field is automatically taken as argument, so there is no need to specify it manually in that case.","category":"page"},{"location":"generator/#Handles","page":"Generator","title":"Handles","text":"","category":"section"},{"location":"generator/","page":"Generator","title":"Generator","text":"Handles are represented as opaque (void) pointers in the API. They have to be created (resp. destroyed) using specific creation (destruction) functions.","category":"page"},{"location":"generator/#Creation","page":"Generator","title":"Creation","text":"","category":"section"},{"location":"generator/","page":"Generator","title":"Generator","text":"Constructors were added to the corresponding Handle structs, which removes the need to manually call these creation functions.","category":"page"},{"location":"generator/#Finalization","page":"Generator","title":"Finalization","text":"","category":"section"},{"location":"generator/","page":"Generator","title":"Generator","text":"Handles are wrapped in a mutable structure that allows the registration of its VkDestroy* finalizer upon instantiation. Therefore, finalizing a handle is as simple as calling Base.finalize(handle). However, the order of finalization is not guaranteed in Julia, while a specific order needs to be maintained (i.e. finalizing device objects before the device itself). Therefore, finalization will have to be triggered manually. All the required arguments to VkDestroy* are passed upon creation of the handle, conforming to valid API usage (creating and destroying an object must be done with the same allocator).","category":"page"},{"location":"generator/","page":"Generator","title":"Generator","text":"For example, let's say we have a VkInstance and a VkDevice. The device needs to be finalized prior to the instance with VkDestroyDevice before calling VkDestroyInstance. The corresponding Instance and Device structures make it easier by only having to call Base.finalize.([device, instance]) (note the order of the arguments; putting the instance first would result in a savage crash).","category":"page"},{"location":"generator/#API-usage-patterns","page":"Generator","title":"API usage patterns","text":"","category":"section"},{"location":"generator/#Pointer-and-array-filling","page":"Generator","title":"Pointer and array filling","text":"","category":"section"},{"location":"generator/","page":"Generator","title":"Generator","text":"Some functions may ask for a pointer object to be filled in by Vulkan, be it a reference to an object or an array. Pointer objects to fill in should be initialized with an empty Ref, or with an Array of undefined elements. Setting up Ref and Array objects are now done automatically and are no longer the responsibility of the programmer.","category":"page"},{"location":"generator/#Enumerations","page":"Generator","title":"Enumerations","text":"","category":"section"},{"location":"generator/","page":"Generator","title":"Generator","text":"Sometimes, when enumerating objects or properties for example, a function may need to be called twice: a first time for returning the number of elements to be enumerated, then a second time with an initialized array of the right length to be filled with Vulkan objects. The relevant enumeration functions are wrapped with these two calls, so that only one calls needs to be made, without worrying about creating intermediate arrays.","category":"page"},{"location":"generator/#Array-arguments","page":"Generator","title":"Array arguments","text":"","category":"section"},{"location":"generator/","page":"Generator","title":"Generator","text":"Array variables are passed in functions as pointers, with a length argument that tells Vulkan how far to jump in memory to recover its elements. Manually specifying the length is no longer necessary in the wrapped functions, as the length argument of the array variable is simply passed in as length(array).","category":"page"},{"location":"generator/#Type-conversion","page":"Generator","title":"Type conversion","text":"","category":"section"},{"location":"generator/","page":"Generator","title":"Generator","text":"Version numbers and Bool objects were represented as UInt32, Strings as Ptr{UInt8} or NTuple{N, UInt8}. They are now represented correctly as VersionNumber, Bool and String objects. For example, this means that when passing or receiving version numbers, one will only have to worry about VersionNumbers.","category":"page"},{"location":"generator/#Error-codes","page":"Generator","title":"Error codes","text":"","category":"section"},{"location":"generator/","page":"Generator","title":"Generator","text":"In the Vulkan API, some functions can return error codes. To avoid silent errors happening unnoticed, one should always check the return value of the relevant functions. With the wrapper, error codes are checked for automatically, raising a VulkanError which holds the corresponding returncode field when the code is an error. A warning is issued if the operation is successful, but different than VkSuccess.","category":"page"},{"location":"generator/#Miscellaneous","page":"Generator","title":"Miscellaneous","text":"","category":"section"},{"location":"generator/#Minor-improvements-to-VulkanCore-structures","page":"Generator","title":"Minor improvements to VulkanCore structures","text":"","category":"section"},{"location":"generator/","page":"Generator","title":"Generator","text":"Structure field types follow a consistent notation throughout the library. For example, Cfloat and Cint are just aliases for Float32 and Int32, and have been replaced accordingly in the wrapped versions.","category":"page"},{"location":"intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Vulkan is a high-level compute and graphics specification, targeting a broad range of GPUs. Because it is only a specification, there does not exist only one Vulkan library, but rather multiple device-dependent implementations conforming to a unique standard. The version of the Vulkan implementation you are using therefore depends on the driver installed for your GPU.","category":"page"},{"location":"troubleshooting/#Troubleshooting","page":"Troubleshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Here we list common errors that can be encountered, with common solutions.","category":"page"},{"location":"troubleshooting/#VK_ERROR_LAYER_NOT_PRESENT","page":"Troubleshooting","title":"VK_ERROR_LAYER_NOT_PRESENT","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Most layers are not bundled with the default Vulkan driver. For example, the validation layer VK_LAYER_KHRONOS_validation should be installed from their Github Page. This specific layer should hopefully be integrated in the artifact system in the future, but other layers may be vendor-dependent, and therefore it is the responsibility of the user to install them before hand.","category":"page"},{"location":"troubleshooting/#Validation-layers-'GLIBCXX_X.X.XX'-not-found","page":"Troubleshooting","title":"Validation layers - 'GLIBCXX_X.X.XX' not found","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"The Khronos validation layer requires a libstc++ more recent than the old found on Julia binaries. A workaround is to build Julia from source, with an up to date libstdc++ on the system, as indicated in this issue on Discourse.","category":"page"},{"location":"troubleshooting/#XCB-Window-can't-open-(CONN_PARSE_ERR)","page":"Troubleshooting","title":"XCB Window can't open (CONN_PARSE_ERR)","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Check that your DISPLAY variable is correctly set (ENV[\"DISPLAY\"] should typically return :0 or :1, the correct value depends on your setup).","category":"page"},{"location":"troubleshooting/#based-vs-1-based-indexing","page":"Troubleshooting","title":"0-based vs 1-based indexing","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Vulkan uses a 0-based indexing system, so be careful whenever an index is returned from or requested for a Vulkan function.","category":"page"},{"location":"#Vulkan.jl","page":"Home","title":"Vulkan.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package wraps the Vulkan library and exposes high-level abstractions. It ranges from convenience abstractions that ease the manipulation of the API to opinionated abstractions with loss of functionality geared towards common uses.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It builds upon the core API provided by the VulkanCore.jl package. Because Vulkan is originally a C library, it requires some knowledge to be correctly used from Julia. An abstraction layer was generated to avoid having to know anything about how C works, while still retaining the full functionality of the original library with minimal overhead. The wrapper generation relies on the Vulkan Specification. This layer automates patterns commonly found as part of the API usage.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"intro.md\", \"api.md\", \"utility.md\", \"troubleshooting.md\"]","category":"page"}]
}
