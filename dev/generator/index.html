<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Generator · Vulkan.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Vulkan.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../utility/">Utility</a></li><li><a class="tocitem" href="../troubleshooting/">Troubleshooting</a></li><li><span class="tocitem">Developer documentation</span><ul><li class="is-active"><a class="tocitem" href>Generator</a><ul class="internal"><li><a class="tocitem" href="#Wrapper-content"><span>Wrapper content</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer documentation</a></li><li class="is-active"><a href>Generator</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Generator</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/serenity4/Vulkan.jl/blob/master/docs/src/generator.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p>Vulkan is a low-level API that exhibits many patterns than any C library exposes. For example, some functions return error codes as a result, or mutate pointer memory as a way of returning multiple values (what would correspond to Julia <code>Array</code>s). The length of array pointers are requested, while directly available as a Julia object. Pointers are the primary objects of interest, while it is not trivial to keep them valid (i.e. have them point to valid memory) in Julia. Their validity is not guaranteed out of the box, which introduces several pitfalls that ultimately lead to crashes. Notably, the API makes a heavy use of structures with pointer fields and structure pointers, which demands a clear knowledge of variable preservation in Julia.</p><p>Usually, the patterns mentioned above are not problematic for small libraries, because structures are relatively simple. They however become visible annoyances in the case of a large API such as Vulkan. This motivates the use of a procedural approach to handle those patterns.</p><p>Vulkan.jl uses a generator to programmatically generate higher-level wrappers for low-level API functions. This is a consequent part of this library, which allowed us to minimize the amount of human errors in the wrapping process, dealing with the patterns mentioned above. The related project is found in the <code>generator</code> folder. Its unique purpose is to generate the file <code>generated/wrapped_api.jl</code>.</p><h2 id="Wrapper-content"><a class="docs-heading-anchor" href="#Wrapper-content">Wrapper content</a><a id="Wrapper-content-1"></a><a class="docs-heading-anchor-permalink" href="#Wrapper-content" title="Permalink"></a></h2><h3 id="Structures"><a class="docs-heading-anchor" href="#Structures">Structures</a><a id="Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Structures" title="Permalink"></a></h3><p>API structures often use pointer fields to pass other structures around, or to have the pointed object filled in by the API, similarly to an assignment. To function properly in Julia, the pointed data has to be conserved in order for the pointer to be valid. Having it conserved here means that it should not be garbage-collected, and used so that compiler optimizations cannot decide to elide the computation. A common way to do this is to store the data in structure fields. Therefore, API structures should have additional fields to preserve variables that are in use by a pointer. However, changing their layout would make them unsuitable for API calls. New structures were generated for each corresponding API structure. They have two fields:</p><ul><li>a <code>vks</code> field, which holds the API structure,</li><li>a <code>bag</code> field, which contains all dependencies required for the API structure to work properly. This mostly includes original data that is used by pointers.</li></ul><p>When using an API function with <code>ccall</code>, the <code>vks</code> field is automatically taken as argument, so there is no need to specify it manually in that case.</p><h3 id="Handles"><a class="docs-heading-anchor" href="#Handles">Handles</a><a id="Handles-1"></a><a class="docs-heading-anchor-permalink" href="#Handles" title="Permalink"></a></h3><p>Handles are represented as opaque (void) pointers in the API. They have to be created (resp. destroyed) using specific creation (destruction) functions.</p><h4 id="Creation"><a class="docs-heading-anchor" href="#Creation">Creation</a><a id="Creation-1"></a><a class="docs-heading-anchor-permalink" href="#Creation" title="Permalink"></a></h4><p>Constructors were added to the corresponding <a href="../api/#Vulkan.Handle"><code>Handle</code></a> structs, which removes the need to manually call these creation functions.</p><h4 id="Finalization"><a class="docs-heading-anchor" href="#Finalization">Finalization</a><a id="Finalization-1"></a><a class="docs-heading-anchor-permalink" href="#Finalization" title="Permalink"></a></h4><p>Handles are wrapped in a mutable structure that allows the registration of its VkDestroy* finalizer upon instantiation. Therefore, finalizing a handle is as simple as calling <code>Base.finalize(handle)</code>. However, the order of finalization is not guaranteed in Julia, while a specific order needs to be maintained (i.e. finalizing device objects before the device itself). Therefore, finalization will have to be triggered manually. All the required arguments to VkDestroy* are passed upon creation of the handle, conforming to valid API usage (creating and destroying an object must be done with the same allocator).</p><p>For example, let&#39;s say we have a <code>VkInstance</code> and a <code>VkDevice</code>. The device needs to be finalized prior to the instance with <code>VkDestroyDevice</code> before calling <code>VkDestroyInstance</code>. The corresponding <code>Instance</code> and <code>Device</code> structures make it easier by only having to call <code>Base.finalize.([device, instance])</code> (note the order of the arguments; putting the instance first would result in a savage crash).</p><h3 id="API-usage-patterns"><a class="docs-heading-anchor" href="#API-usage-patterns">API usage patterns</a><a id="API-usage-patterns-1"></a><a class="docs-heading-anchor-permalink" href="#API-usage-patterns" title="Permalink"></a></h3><h4 id="Pointer-and-array-filling"><a class="docs-heading-anchor" href="#Pointer-and-array-filling">Pointer and array filling</a><a id="Pointer-and-array-filling-1"></a><a class="docs-heading-anchor-permalink" href="#Pointer-and-array-filling" title="Permalink"></a></h4><p>Some functions may ask for a pointer object to be filled in by Vulkan, be it a reference to an object or an array. Pointer objects to fill in should be initialized with an empty <code>Ref</code>, or with an <code>Array</code> of undefined elements. Setting up <code>Ref</code> and <code>Array</code> objects are now done automatically and are no longer the responsibility of the programmer.</p><h4 id="Enumerations"><a class="docs-heading-anchor" href="#Enumerations">Enumerations</a><a id="Enumerations-1"></a><a class="docs-heading-anchor-permalink" href="#Enumerations" title="Permalink"></a></h4><p>Sometimes, when enumerating objects or properties for example, a function may need to be called twice: a first time for returning the number of elements to be enumerated, then a second time with an initialized array of the right length to be filled with Vulkan objects. The relevant enumeration functions are wrapped with these two calls, so that only one calls needs to be made, without worrying about creating intermediate arrays.</p><h4 id="Array-arguments"><a class="docs-heading-anchor" href="#Array-arguments">Array arguments</a><a id="Array-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Array-arguments" title="Permalink"></a></h4><p>Array variables are passed in functions as pointers, with a length argument that tells Vulkan how far to jump in memory to recover its elements. Manually specifying the length is no longer necessary in the wrapped functions, as the length argument of the array variable is simply passed in as <code>length(array)</code>.</p><h4 id="Type-conversion"><a class="docs-heading-anchor" href="#Type-conversion">Type conversion</a><a id="Type-conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Type-conversion" title="Permalink"></a></h4><p>Version numbers and <code>Bool</code> objects were represented as <code>UInt32</code>, <code>Strings</code> as <code>Ptr{UInt8}</code> or <code>NTuple{N, UInt8}</code>. They are now represented correctly as <code>VersionNumber</code>, <code>Bool</code> and <code>String</code> objects. For example, this means that when passing or receiving version numbers, one will only have to worry about <code>VersionNumber</code>s.</p><h4 id="Error-codes"><a class="docs-heading-anchor" href="#Error-codes">Error codes</a><a id="Error-codes-1"></a><a class="docs-heading-anchor-permalink" href="#Error-codes" title="Permalink"></a></h4><p>In the Vulkan API, some functions can return error codes. To avoid silent errors happening unnoticed, one should always check the return value of the relevant functions. With the wrapper, error codes are checked for automatically, raising a <code>VulkanError</code> which holds the corresponding <code>returncode</code> field when the code is an error. A warning is issued if the operation is successful, but different than <code>VkSuccess</code>.</p><h3 id="Miscellaneous"><a class="docs-heading-anchor" href="#Miscellaneous">Miscellaneous</a><a id="Miscellaneous-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous" title="Permalink"></a></h3><h4 id="Minor-improvements-to-VulkanCore-structures"><a class="docs-heading-anchor" href="#Minor-improvements-to-VulkanCore-structures">Minor improvements to VulkanCore structures</a><a id="Minor-improvements-to-VulkanCore-structures-1"></a><a class="docs-heading-anchor-permalink" href="#Minor-improvements-to-VulkanCore-structures" title="Permalink"></a></h4><p>Structure field types follow a consistent notation throughout the library. For example, <code>Cfloat</code> and <code>Cint</code> are just aliases for <code>Float32</code> and <code>Int32</code>, and have been replaced accordingly in the wrapped versions.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../troubleshooting/">« Troubleshooting</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 23 November 2020 08:36">Monday 23 November 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
